HTTP协议-HyperText Transfer Protocol，超文本传输协议
协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，
它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器.
目前我们使用的是HTTP/1.1 版本

当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？
实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 
浏览器解析Response中的HTML,这样我们就看到了网页.

URL详解
URL(Uniform Resource Locator) 地址用于描述一个网络上的资源，  基本格式如下
schema://host[:port#]/path/.../[;url-params][?query-string][#anchor]

scheme               指定低层使用的协议(例如：http, https, ftp)
host                 HTTP服务器的IP地址或者域名
port#                HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/
path                 访问资源的路径
url-params           
query-string         发送给http服务器的数据
anchor-              锚

URL 的一个例子
http://www.mywebsite.com/sj/test;id=8079?name=sviergn&x=true#stuff
Schema: http
host: www.mywebsite.com
path: /sj/test
URL params: id=8079
Query String: name=sviergn&x=true
Anchor: stuff

HTTP协议是无状态的
http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， 
Web程序引入了Cookie机制来维护状态.

HTTP消息的结构
Request 消息的结构
Request 消息分为3部分，第一部分叫请求行， 第二部分叫http header, 第三部分是body. header和body之间有个空行
eg:
POST /examples/default.jsp HTTP/1.1   --(URI)—Protocol/Version 
                           
Accept: text/plain; text/html         --Request Header      
Accept-Language: en-gb 
Connection: Keep-Alive 
Host: localhost 
User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows 98) 
Content-Length: 33 
Content-Type: application/x-www-form-urlencoded 
Accept-Encoding: gzip, deflate 
                                      --There is a blank line(CRLF)
lastName=Franks&firstName=Michael     --Entity Body

第一行中的Method表示请求方法,比如"POST","GET",  Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号
当使用的是"GET" 方法的时候， body是为空的

Response消息的结构分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. 
header和body之间也有个空行
eg:
HTTP/1.1 200 OK                                          --Protocol/Version   Status code   Description 
Server: Microsoft-IIS/4.0 
Date: Mon, 5 Jan 2004 13:13:33 GMT 
Content-Type: text/html 
Last-Modified: Mon, 5 Jan 2004 13:13:12 GMT 
Content-Length: 112 

<html> 
<head> 
<title>HTTP Response Example</title> 
</head> 
<body> 
Welcome to Brainy Software 
</body> 
</html> 



get和post

HTTP 定义了与服务器交互的不同方法，最常用的有4种，Get、Post、Put、Delete,如果我换一下顺序就好记了，Put（增）,Delete（删），Post（改）,Get（查），即增删改查，下面简单叙述一下：
1）Get， 它用于获取信息，注意，他只是获取、查询数据，也就是说它不会修改服务器上的数据，从这点来讲，它是数据安全的，
   而稍后会提到的Post它是可以修改数据的，所以这也是两者差别之一。
2）Post，它是可以向服务器发送修改请求，从而修改服务器的，比方说，我们要在论坛上回贴、在博客上评论，这就要用到Post了，当然它也是可以仅仅获取数据的。
3）Delete 删除数据。可以通过Get/Post来实现。用的不多
4）Put，增加、放置数据，可以通过Get/Post来实现。用的不多

区别：
1） GET请求的数据是放在HTTP包头中的，也就是URL之后，通常是像下面这样定义格式的，（而Post是把提交的数据放在HTTP正文中的）。
login.action?name=hyddd&password=idontknow&verify=%E4%BD%E5%A5%BD
a，以 ？ 来分隔URL和数据； 
b，以& 来分隔参数；
c，如果数据是英文或数字，原样发送；
d，如果数据是中文或其它字符，则进行BASE64编码。  

2）GET提交的数据比较少，最多1024B，因为GET数据是附在URL之后的，而URL则会受到不同环境的限制的，比如说IE对其限制为2K+35，
  而POST可以传送更多的数据（理论上是没有限制的，但一般也会受不同的环境，如浏览器、操作系统、服务器处理能力等限制，IIS4可支持80KB，IIS5可支持100KB）。
  注：HTTP协议对GET和POST都没有对长度的限制，对于URL长度上的限制，一是浏览器，二是多数服务器出于安全、稳定方面的考虑，会给URL长度加限制。
  但是这个限制是针对所有HTTP请求的，与GET、POST没有关系
  在FORM（表单）中，Method默认为"GET"，实质上，GET和POST只是发送机制不同，并不是一个取一个发.

3）Post的安全性要比Get高，因为Get时，参数数据是明文传输的，而且使用GET的话，还可能造成Cross-site request forgery攻击。
  而POST数据则可以加密的，但GET的速度可能会快些。
  
  
状态码
Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。

状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.

HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别

1XX  提示信息 - 表示请求已被成功接收，继续处理
2XX  成功 - 表示请求已被成功接收，理解，接受
3XX  重定向 - 要完成请求必须进行更进一步的处理
4XX  客户端错误 -  请求有语法错误或请求无法实现
5XX  服务器端错误 -   服务器未能实现合法的请求


一些常见的状态码
200 OK     最常见的就是成功响应状态码200， 这表明该请求被成功地完成，所请求的资源发送回客户端.
302 Found  重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request.
304 Not Modified 代表上次的文档已经被缓存了， 还可以继续使用.
400 Bad Request  客户端请求与语法错误，不能被服务器所理解.
403 Forbidden    服务器收到请求，但是拒绝提供服务.
404 Not Found    请求资源不存在（输错了URL）.
500 Internal Server Error 服务器发生了不可预期的错误.
503 Server Unavailable    服务器当前不能处理客户端的请求，一段时间后可能恢复正常.

Cache-Control:
作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。
如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。
客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.
eg:
If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT
如果请求和响应的If-Modified-Since时间一致，服务器将返回304，告诉客户端使用本地缓存文件

If-None-Match：
If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 
当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），
将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能》










HTTP协议是无状态的和Connection: keep-alive的区别
无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。
从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系.

HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）.
从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，
如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接.
 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间.

  
  
  
