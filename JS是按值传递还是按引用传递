按值传递call by value
按引用传递call by reference
在计算机科学里，这个部分叫求值策略Evaluation Strategy, 它决定变量之间、函数调用时实参和形参之间值是如何传递的

按值传递是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。
按引用传递时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。
按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的BUG。
按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。

JS中的基本类型按值传递，对象类型按共享传递的 call by sharing，也叫按对象传递、按对象共享传递。
最早由Barbara Liskov. 在1974年的GLU语言中提出。该求值策略被用于Python、Java、Ruby、JS等多种语言。

该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 
它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值.
然而，虽然引用是副本，引用的对象是相同的。它们共享相同的对象，所以修改形参对象的属性值，也会影响到实参的属性值。
(解释：对形参整体赋值，等于是指向另一个引用，所以方法体内的引用指向了新地址，产生变化，但是方法执行结束，实参并未发生变化；
对于形参的属性的更改，则是修改了共享对象的属性，这样实参也会跟着变化)

以上结束针对对象的属性是基本类型的情况，但是参数对象属性是对象呢？？？
后续

reference：https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference
