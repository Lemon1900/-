输入和输出 就是 数据源和目标媒介。
Java的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。
以下是最典型的数据源和目标媒介：
文件
管道
网络连接
内存缓存
System.in, System.out, System.error(注：Java标准输入、输出、错误输出)

程序从数据源读取数据，然后将数据输出到其他媒介的原理：
source-program-destination

流
流从概念上来说是一个连续的数据流。
你既可以从流中读取数据，也可以往流中写数据。
流与数据源或者数据流向的媒介相关联。
在Java IO中流既可以是字节流(以字节为单位进行读写)，也可以是字符流(以字符为单位进行读写)。
字节流
字节流通常以“stream”命名，比如InputStream和OutputStream。
除了DataInputStream 和DataOutputStream 还能够读写int, long, float和double类型的值以外，其他流在一个操作时间内只能读取或者写入一个原始字节。
字符流
字符流通常以“Reader”或者“Writer”命名。字符流能够读写字符(比如Latin1或者Unicode字符)。

InputStream
java.io.InputStream类是所有Java IO输入流的基类。
如果你正在开发一个从流中读取数据的组件，请尝试用InputStream替代任何它的子类(比如FileInputStream)进行开发。
这么做能够让你的代码兼容任何类型而非某种确定类型的输入流。
通常使用输入流中的read()方法读取数据。
read()方法返回一个整数，代表了读取到的字节的内容(译者注：0 ~ 255)。
当达到流末尾没有更多数据可以读取的时候，read()方法返回-1。
一个简单的示例：
InputStream input = new FileInputStream("c:\\data\\input-file.txt");
int data = input.read(); 
while(data != -1){
     data = input.read();
}

OutputStream
java.io.OutputStream是Java IO中所有输出流的基类。
如果你正在开发一个能够将数据写入流中的组件，请尝试使用OutputStream替代它的所有子类。
一个简单的示例：
OutputStream output = new FileOutputStream("c:\\data\\output-file.txt");
output.write("Hello World".getBytes());
output.close();

组合流
你可以将流整合起来以便实现更高级的输入和输出操作。
比如，一次读取一个字节是很慢的，所以可以从磁盘中一次读取一大块数据，然后从读到的数据块中获取字节。
为了实现缓冲，可以把InputStream包装到BufferedInputStream中。
代码示例：
InputStream input = new BufferedInputStream(new FileInputStream("c:\\data\\input-file.txt"));
缓冲同样可以应用到OutputStream中。你可以实现将大块数据批量地写入到磁盘(或者相应的流)中，这个功能由BufferedOutputStream实现。
缓冲只是通过流整合实现的其中一个效果。你可以把InputStream包装到PushbackInputStream中，之后可以将读取过的数据推回到流中重新读取，在解析过程中有时候这样做很方便。
或者，你可以将两个InputStream整合成一个SequenceInputStream。
将不同的流整合到一个链中，可以实现更多种高级操作。
通过编写包装了标准流的类，可以实现你想要的效果和过滤器。


一个程序需要InputStream或者Reader从数据源读取数据，或者需要OutputStream或者Writer将数据写入到目标媒介中(InputStream和Reader与数据源相关联，OutputStream和writer与目标媒介相关联)
source---InputStream/Reader---program
program--OutputStream/Writer---destination


Java IO中包含了许多InputStream、OutputStream、Reader、Writer的子类。
这样设计的原因是让每一个类都负责不同的功能。

各类用途汇总如下：
文件访问
网络访问
内存缓存访问
线程内部通信(管道)
缓冲
过滤
解析
读写文本 (Readers / Writers)
读写基本类型数据 (long, int etc.)
读写对象

各个类的具体描述：

InputStream
InputStream用于读取基于字节的数据，一次读取一个字节
InputStream inputstream = new FileInputStream("c:\\data\\input-text.txt");
FileInputStream是InputStream的子类，所以可以把FileInputStream实例赋值给InputStream变量。

read()方法
read()方法返回从InputStream流内读取到的一个字节内容(译者注：0~255)，例子如下：
int data = inputstream.read();
可以把返回的int类型转化成char类型：
char aChar = (char) data;

InputStream的子类可能会包含read()方法的替代方法。
比如，DataInputStream允许你利用readBoolean()，readDouble()等方法读取Java基本类型变量int，long，float，double和boolean。

流末尾
如果read()方法返回-1，意味着程序已经读到了流的末尾，此时流内已经没有多余的数据可供读取了。-1是一个int类型，不是byte或者char类型，这是不一样的。
当达到流末尾时，你就可以关闭流了。

read(byte[])
InputStream包含了2个从InputStream中读取数据并将数据存储到缓冲数组中的read()方法，他们分别是：
int read(byte[])
int read(byte, int offset, int length)
一次性读取一个字节数组的方式，比一次性读取一个字节的方式快的多，所以，尽可能使用这两个方法代替read()方法。

read(byte[])方法会尝试读取与给定字节数组容量一样大的字节数，返回值说明了已经读取过的字节数。
如果InputStream内可读的数据不足以填满字节数组，那么数组剩余的部分将包含本次读取之前的数据。
记得检查有多少数据实际被写入到了字节数组中。

read(byte, int offset, int length)方法同样将数据读取到字节数组中，不同的是，该方法从数组的offset位置开始，并且最多将length个字节写入到数组中。
同样地，read(byte, int offset, int length)方法返回一个int变量，告诉你已经有多少字节已经被写入到字节数组中，
所以请记得在读取数据前检查上一次调用read(byte, int offset, int length)的返回值。

这两个方法都会在读取到达到流末尾时返回-1。

OutputStream：
OutputStream类是Java IO API中所有输出流的基类。子类包括BufferedOutputStream，FileOutputStream等等
当写入到输出流的数据逐渐输出完毕时，目标媒介是所有数据的归属地。
write(byte)方法
write(byte)方法用于把单个字节写入到输出流中。
OutputStream的write(byte)方法将一个包含了待写入数据的int变量作为参数进行写入。
只有int类型的第一个字节会被写入，其余位会被忽略。(译者注：写入低8位，忽略高24位)。

OutputStream的子类可能会包含write()方法的替代方法。
比如，DataOutputStream允许你利用writeBoolean()，writeDouble()等方法将基本类型int，long，float，double，boolean等变量写入。

一个OutputStream的write()方法例子：

OutputStream output = new FileOutputStream("c:\\data\\output-text.txt");
while(hasMoreData()) {
    int data = getMoreData();
    output.write(data);
}
output.close();
hasMoreData()的作用是：当有剩余可写数据时，返回true，否则返回false。
write(byte[])
OutputStream同样包含了将字节数据中全部或者部分数据写入到输出流中的方法，分别是write(byte[])和write(byte[], int offset, int length)。
write(byte[])把字节数组中所有数据写入到输出流中。
write(byte[], int offset, int length)把字节数据中从offset位置开始，length个字节的数据写入到输出流。

flush()
OutputStream的flush()方法将所有写入到OutputStream的数据冲刷到相应的目标媒介中。
比如，如果输出流是FileOutputStream，那么写入到其中的数据可能并没有真正写入到磁盘中。
即使所有数据都写入到了FileOutputStream，这些数据还是有可能保留在内存的缓冲区中。
通过调用flush()方法，可以把缓冲区内的数据刷新到磁盘(或者网络，以及其他任何形式的目标媒介)中。

close()
当你结束数据写入时，需要关闭OutputStream。通过调用close()可以达到这一点。
因为OutputStream的各种write()方法可能会抛出IO异常，所以你需要把调用close()的关闭操作方在finally块中执行。


FileInputStream：
FileInputStream可以以字节流的形式读取文件内容。
FileInputStream是InputStream的子类，这意味着你可以把FileInputStream当做InputStream使用(FileInputStream与InputStream的行为类似)。

一个FileInputStream的例子：
InputStream input = new FileInputStream("c:\\data\\input-text.txt");
int data = input.read();while(data != -1) {
    //do something with data...
    doSomethingWithData(data);
    data = input.read();
}
input.close();

FileInputStream也有其他的构造函数，允许你通过不同的方式读取文件。(请移步阅读源码)
根据官方文档，FileInputStream有三个构造器
Creates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system.
Creates a FileInputStream by using the file descriptor fdObj, which represents an existing connection to an actual file in the file system.
Creates a FileInputStream by opening a connection to an actual file, the file named by the path name name in the file system.

至于你该采用参数是String对象还是File对象的构造函数，取决于你当前是否已经拥有一个File对象，
也取决于你是否要在打开FileOutputStream之前通过File对象执行某些检查(比如检查文件是否存在)。

FileOutputStream
FileOutputStream可以往文件里写入字节流，它是OutputStream的子类，所以你可以像使用OutputStream那样使用FileOutputStream。

文件内容的覆盖Override、追加Appending
当你创建了一个指向已存在文件的FileOutputStream，你可以选择覆盖整个文件，或者在文件末尾追加内容。通过使用不同的构造函数可以实现不同的目的。
OutputStream output = new FileOutputStream("c:\\data\\output-text.txt");//overwrites file
OutputStream output = new FileOutputStream("c:\\data\\output-text.txt", true); //appends to file
OutputStream output = new FileOutputStream("c:\\data\\output-text.txt", false); //overwrites file

ByteArrayInputStream
ByteArrayOutputStream
ByteArrayInputStream允许你从字节数组中读取字节流数据
eg:
byte[] bytes = ... //get byte array from somewhere.
InputStream input = new ByteArrayInputStream(bytes);
int data = input.read();
while(data != -1) {
    //do something with data
    data = input.read();
}
input.close();

ByteArrayOutputStream允许你以数组的形式获取写入到该输出流中的数据
ByteArrayOutputStream output = new ByteArrayOutputStream();
//write data to output stream
byte[] bytes = output.toByteArray();


BufferedInputStream
BufferedOutputStream
BufferedInputStream能为输入流提供缓冲区，能提高很多IO的速度。
你可以一次读取一大块的数据，而不需要每次从网络或者磁盘中一次读取一个字节。特别是在访问大量磁盘数据时，缓冲通常会让IO快上许多。
为了给你的输入流加上缓冲，你需要把输入流包装到BufferedInputStream中.
InputStream input = new BufferedInputStream(new FileInputStream("c:\\data\\input-file.txt"));
很简单.你可以给BufferedInputStream的构造函数传递一个值，设置内部使用的缓冲区设置大小(译者注：默认缓冲区大小8 * 1024B)，就像这样：
InputStream input = new BufferedInputStream(new FileInputStream("c:\\data\\input-file.txt"), 8 * 1024);
这个例子设置了8KB的缓冲区。最好把缓冲区大小设置成1024字节的整数倍，这样能更高效地利用内置缓冲区的磁盘。
除了能够为输入流提供缓冲区以外，其余方面BufferedInputStream基本与InputStream类似

与BufferedInputStream类似，BufferedOutputStream可以为输出流提供缓冲区。可以构造一个使用默认大小缓冲区的BufferedOutputStream(译者注：默认缓冲区大小8 * 1024B)


DataInputStream
DataOutputStream
DataInputStream可以使你从输入流中读取Java基本类型数据，而不必每次读取字节数据。
你可以把InputStream包装到DataInputStream中，然后就可以从此输入流中读取基本类型数据了
DataInputStream input = new DataInputStream(new FileInputStream("binary.data"));
int aByte = input.read();
int anInt = input.readInt();
float aFloat = input.readFloat();
double aDouble = input.readDouble();//etc.
input.close();

DataOutputStream可以往输出流中写入Java基本类型数据，例子如下：
DataOutputStream output = new DataOutputStream(new FileOutputStream("binary.data"));
output.write(45);
//byte data output.writeInt(4545);
//int data output.writeDouble(109.123);
//double data  output.close();

ObjectInputStream
ObjectOutputStream
ObjectInputStream能够让你从输入流中读取Java对象，而不需要每次读取一个字节。
你可以把InputStream包装到ObjectInputStream中，然后就可以从中读取对象了
bjectInputStream input = new ObjectInputStream(new FileInputStream("object.data"));
MyClass object = (MyClass) input.readObject(); //etc.
input.close();
在这个例子中，你读取的对象必须是MyClass的一个实例，并且必须事先通过ObjectOutputStream序列化到“object.data”文件中

ObjectOutputStream能够让你把对象写入到输出流中，而不需要每次写入一个字节。
你可以把OutputStream包装到ObjectOutputStream中，然后就可以把对象写入到该输出流中了。
ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream("object.data"));
MyClass object = new MyClass();  output.writeObject(object); //etc.
output.close();
例子中序列化的对象object现在可以从ObjectInputStream中读取了。


Reader 
Writer
Reader是Java IO中所有Reader的基类。
Reader与InputStream类似，不同点在于，Reader基于字符而非基于字节。
换句话说，Reader用于读取文本，而InputStream用于读取原始字节。
Reader通常与文件、字符数组、网络等数据源相关联.
Java内部使用UTF8编码表示字符串。
输入流中一个字节可能并不等同于一个UTF8字符。如果你从输入流中以字节为单位读取UTF8编码的文本，并且尝试将读取到的字节转换成字符，你可能会得不到预期的结果。

read()方法返回一个包含了读取到的字符内容的int类型变量(译者注：0~65535)。如果方法返回-1，表明Reader中已经没有剩余可读取字符，此时可以关闭Reader。
-1是一个int类型，不是byte或者char类型，这是不一样的。
你通常会使用Reader的子类，而不会直接使用Reader。Reader的子类包括InputStreamReader，CharArrayReader，FileReader等等。

Writer是Java IO中所有Writer的基类。
与Reader和InputStream的关系类似，Writer基于字符而非基于字节，Writer用于写入文本，OutputStream用于写入字节。
同样，你最好使用Writer的子类，不需要直接使用Writer，因为子类的实现更加明确，更能表现你的意图。
常用子类包括OutputStreamWriter，CharArrayWriter，FileWriter等。
Writer的write(int c)方法，会将传入参数的低16位写入到Writer中，忽略高16位的数据。


InputStreamReader
OutputStreamWriter
这两个类把字节流转换成字符流，中间做了数据的转换，类似适配器模式的思想
InputStreamReader的构造器：
InputStreamReader(InputStream in)
Creates an InputStreamReader that uses the default charset.
InputStreamReader(InputStream in, Charset cs)
Creates an InputStreamReader that uses the given charset.
InputStreamReader(InputStream in, CharsetDecoder dec)
Creates an InputStreamReader that uses the given charset decoder.
InputStreamReader(InputStream in, String charsetName)
Creates an InputStreamReader that uses the named charset.

其他的构造函数，能够让你指定将底层字节流解释成何种编码的字符流

InputStreamReader会包含一个InputStream，从而可以将该输入字节流转换成字符流
InputStream inputStream = new FileInputStream("c:\\data\\input.txt");
Reader reader = new InputStreamReader(inputStream);
int data = reader.read();
while(data != -1){
    char theChar = (char) data;
    data = reader.read();
}
reader.close();

read()方法返回一个包含了读取到的字符内容的int类型变量(译者注：0~65535)
int data = reader.read();
你可以把返回的int值转换成char变量，就像这样：
char aChar = (char) data; //译者注：这里不会造成数据丢失，因为返回的int类型变量data只有低16位有数据，高16位没有数据
如果方法返回-1，表明Reader中已经没有剩余可读取字符，此时可以关闭Reader。-1是一个int类型，不是byte或者char类型，这是不一样的。

OutputStreamWriter会包含一个OutputStream，从而可以将该输出字节流转换成字符流
OutputStream outputStream = new FileOutputStream("c:\\data\\output.txt");
Writer writer = new OutputStreamWriter(outputStream);
writer.write("Hello World");
writer.close();
OutputStreamWriter同样拥有将输出字节流转换成指定编码的字符流的构造函数。


FileReader与FileWriter用于处理文件内容。
FileReader能够以字符流的形式读取文件内容。
除了读取的单位不同之外(注：FileReader读取字符，FileInputStream读取字节)，FileReader与FileInputStream并无太大差异，
也就是说，FileReader用于读取文本。根据不同的编码方案，一个字符可能会相当于一个或者多个字节。
Reader reader = new FileReader("c:\\data\\input-text.txt");
int data = reader.read();
while(data != -1) {
    //do something with data...
    doSomethingWithData(data);
    data = reader.read();
}
reader.close();
FileReader拥有其他可选的构造函数，能够让你使用不同的方式读取文件，更多内容请查看官方文档。（类似FileInputStream）
FileReader会假设你想使用你所使用的JVM的版本的默认编码处理字节流，但是这通常不是你想要的，你可以手动设置编码方案。
如果你想明确指定一种编码方案，利用InputStreamReader配合FileInputStream来替代FileReader(译者注：FileReader没有可以指定编码的构造函数)。
InputStreamReader可以让你设置编码处理从底层文件中读取的字节。

FileWriter能够把数据以字符流的形式写入文件。
同样是处理文件，FileWriter处理字符，FileOutputStream处理字节。根据不同的编码方案，一个字符可能会相当于一个或者多个字节。
Writer writer = new FileWriter("c:\\data\\output.txt");
while(moreData) {
    String data = getMoreData();
    write.write(data);
}
writer.close();
处理文件都会碰到的一个问题是，当前写入的数据是覆盖原文件内容还是追加到文件末尾。
当你创建一个FileWriter之后，你可以通过使用不同构造函数实现你的不同目的。

以下的构造函数取文件名作为参数，将会新写入的内容将会覆盖该文件：
Writer writer = new FileWriter("c:\\data\\output.txt");
以下的构造函数取文件名和一个布尔变量作为参数，布尔值表明你是想追加还是覆盖该文件。例子如下：
Writer writer = new FileWriter("c:\\data\\output.txt", true); //appends to file
Writer writer = new FileWriter("c:\\data\\output.txt", false); //overwrites file
同样，FileWriter不能指定编码，可以通过OutputStreamWriter配合FileOutputStream替代FileWriter。


BufferedReader
BufferedWriter
BufferedReader和BufferedInputStream的主要区别在于，BufferedReader操作字符，而BufferedInputStream操作原始字节。
只需要把Reader包装到BufferedReader中，就可以为Reader添加缓冲区(译者注：默认缓冲区大小为8192字节，即8KB)
Reader input = new BufferedReader(new FileReader("c:\\data\\input-file.txt"));
你也可以通过传递构造函数的第二个参数，指定缓冲区大小，代码如下：
Reader input = new BufferedReader(new FileReader("c:\\data\\input-file.txt"), 8 * 1024);
这个例子设置了8KB的缓冲区。最好把缓冲区大小设置成1024字节的整数倍，这样能更高效地利用内置缓冲区的磁盘。
除了能够为输入流提供缓冲区以外，其余方面BufferedReader基本与Reader类似。BufferedReader还有一个额外readLine()方法，可以方便地一次性读取一整行字符。

与BufferedReader类似，BufferedWriter可以为输出流提供缓冲区。可以构造一个使用默认大小缓冲区的BufferedWriter(译者注：默认缓冲区大小8 * 1024B)
Writer writer = new BufferedWriter(new FileWriter("c:\\data\\output-file.txt"));
也可以手动设置缓冲区大小，代码如下：
Writer writer = new BufferedWriter(new FileWriter("c:\\data\\output-file.txt"), 8 * 1024);
为了更好地使用内置缓冲区的磁盘，同样建议把缓冲区大小设置成1024的整数倍。除了能够为输出流提供缓冲区以外，其余方面BufferedWriter基本与Writer类似。
类似地，BufferedWriter也提供了writeLine()方法，能够把一行字符写入到底层的字符输出流中。
值得注意是，你需要手动flush()方法确保写入到此输出流的数据真正写入到磁盘或者网络中。

CharArrayReader能够让你从字符数组中读取字符流
CharArrayWriter能够把字符写入到字符输出流writer中，并且能够将写入的字符转换成字符数组

char[] chars = ... //get char array from somewhere.
Reader reader = new CharArrayReader(chars);
int data = reader.read();
while(data != -1) {
    //do something with data
    data = reader.read();
}
reader.close();

CharArrayWriter writer = new CharArrayWriter();
//write characters to writer.
char[] chars = writer.toCharArray();


io中的其他字节流
PushbackInputStream，SequenceInputStream和PrintStream

PushbackInputStream用于解析InputStream内的数据。有时候你需要提前知道接下来将要读取到的字节内容，才能判断用何种方式进行数据解析。
PushBackInputStream允许你这么做，你可以把读取到的字节重新推回到InputStream中，以便再次通过read()读取。
eg:
PushbackInputStream input = new PushbackInputStream(new FileInputStream("c:\\data\\input.txt"));
int data = input.read();
input.unread(data);

可以通过PushBackInputStream的构造函数设置推回缓冲区的大小，代码如下：
PushbackInputStream input = new PushbackInputStream(new FileInputStream("c:\\data\\input.txt"), 8);
这个例子设置了8个字节的缓冲区，意味着你最多可以重新读取8个字节的数据

SequenceInputStream
SequenceInputStream把一个或者多个InputStream整合起来，形成一个逻辑连贯的输入流。
当读取SequenceInputStream时，会先从第一个输入流中读取，完成之后再从第二个输入流读取，以此推类。
InputStream input1 = new FileInputStream("c:\\data\\file1.txt");
InputStream input2 = new FileInputStream("c:\\data\\file2.txt");
InputStream combined = new SequenceInputStream(input1, input2);
SequenceInputStream的read()方法会在读取到当前流末尾时，关闭流，并把当前流指向逻辑链中的下一个流，最后返回新的当前流的read()值)。

PrintStream
PrintStream允许你把格式化数据写入到底层OutputStream中。比如，写入格式化成文本的int，long以及其他原始数据类型到输出流中，而非它们的字节数据。
PrintStream包含2个强大的函数，分别是format()和printf()(这两个函数几乎做了一样的事情，但是C程序员会更熟悉printf())。


Java IO: 其他字符流
PushbackReader，LineNumberReader，StreamTokenizer，PrintWriter，StringReader，StringWriter.

PushbackReader与PushbackInputStream类似，唯一不同的是PushbackReader处理字符，PushbackInputStream处理字节。代码如下：
PushbackReader reader = new PushbackReader(new FileReader("c:\\data\\input.txt"));
int data = reader.read();
reader.unread(data);
同样可以设置缓冲区大小，代码如下：
PushbackReader reader = new PushbackReader(new FileReader("c:\\data\\input.txt"), 8);

LineNumberReader是记录了已读取数据行号的BufferedReader。默认情况下，行号从0开始，当LineNumberReader读取到行终止符时，行号会递增(译者注：换行\n，回车\r，或者换行回车\n\r都是行终止符)。

你可以通过getLineNumber()方法获取当前行号，通过setLineNumber()方法设置当前行数(译者注：setLineNumber()仅仅改变LineNumberReader内的记录行号的变量值，不会改变当前流的读取位置。
流的读取依然是顺序进行，意味着你不能通过setLineNumber()实现流的跳跃读取)。代码如下：
LineNumberReader reader = new LineNumberReader(new FileReader("c:\\data\\input.txt"));
int data = reader.read();
while(data != -1){
    char dataChar = (char) data;
    data = reader.read();
    int lineNumber = reader.getLineNumber();
}
如果解析的文本有错误，LineNumberReader可以很方便地定位问题。当你把错误报告给用户时，如果能够同时把出错的行号提供给用户，用户就能迅速发现并且解决问题。


StreamTokenizer
StreamTokenizer(译者注：请注意不是StringTokenizer)可以把输入流(译者注：InputStream和Reader。
通过InputStream构造StreamTokenizer的构造函数已经在JDK1.1版本过时，推荐将InputStream转化成Reader，
再利用此Reader构造StringTokenizer)分解成一系列符号。比如，句子”Mary had a little lamb”的每个单词都是一个单独的符号。

当你解析文件或者计算机语言时，为了进一步的处理，需要将解析的数据分解成符号。通常这个过程也称作分词。
通过循环调用nextToken()可以遍历底层输入流的所有符号。
在每次调用nextToken()之后，StreamTokenizer有一些变量可以帮助我们获取读取到的符号的类型和值。
这些变量是：
ttype 读取到的符号的类型(字符，数字，或者行结尾符)
sval 如果读取到的符号是字符串类型，该变量的值就是读取到的字符串的值
nval 如果读取到的符号是数字类型，该变量的值就是读取到的数字的值

代码如下：
StreamTokenizer tokenizer = new StreamTokenizer(new StringReader("Mary had 1 little lamb..."));
while(tokenizer.nextToken() != StreamTokenizer.TT_EOF){
    if(tokenizer.ttype == StreamTokenizer.TT_WORD) {
        System.out.println(tokenizer.sval);
    } else if(tokenizer.ttype == StreamTokenizer.TT_NUMBER) {
        System.out.println(tokenizer.nval);
    } else if(tokenizer.ttype == StreamTokenizer.TT_EOL) {
        System.out.println();
    }
}
译者注：TT_EOF表示流末尾，TT_EOL表示行末尾。

StreamTokenizer可以识别标示符，数字，引用的字符串，和多种注释类型。你也可以指定何种字符解释成空格、注释的开始以及结束等。
在StreamTokenizer开始解析之前，所有的功能都可以进行配置。请查阅官方文档获取更多信息。


StringReader
StringReader能够将原始字符串转换成Reader，代码如下：
Reader reader = new StringReader("input string...");
int data = reader.read();
while(data != -1) {
    //do something with data...
    doSomethingWithData(data);
    data = reader.read();
}
reader.close();

StringWriter
StringWriter能够以字符串的形式从Writer中获取写入到其中数据，代码如下：
StringWriter writer = new StringWriter();
//write characters to writer.
String data = writer.toString();
StringBuffer dataBuffer = writer.getBuffer();
toString()方法能够获取StringWriter中的字符串数据。

getBuffer()方法能够获取StringWriter内部构造字符串时所使用的StringBuffer对象。
