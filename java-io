输入和输出 就是 数据源和目标媒介。
Java的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。
以下是最典型的数据源和目标媒介：
文件
管道
网络连接
内存缓存
System.in, System.out, System.error(注：Java标准输入、输出、错误输出)

程序从数据源读取数据，然后将数据输出到其他媒介的原理：
source-program-destination

流
流从概念上来说是一个连续的数据流。
你既可以从流中读取数据，也可以往流中写数据。
流与数据源或者数据流向的媒介相关联。
在Java IO中流既可以是字节流(以字节为单位进行读写)，也可以是字符流(以字符为单位进行读写)。
字节流
字节流通常以“stream”命名，比如InputStream和OutputStream。
除了DataInputStream 和DataOutputStream 还能够读写int, long, float和double类型的值以外，其他流在一个操作时间内只能读取或者写入一个原始字节。
字符流
字符流通常以“Reader”或者“Writer”命名。字符流能够读写字符(比如Latin1或者Unicode字符)。

InputStream
java.io.InputStream类是所有Java IO输入流的基类。
如果你正在开发一个从流中读取数据的组件，请尝试用InputStream替代任何它的子类(比如FileInputStream)进行开发。
这么做能够让你的代码兼容任何类型而非某种确定类型的输入流。
通常使用输入流中的read()方法读取数据。
read()方法返回一个整数，代表了读取到的字节的内容(译者注：0 ~ 255)。
当达到流末尾没有更多数据可以读取的时候，read()方法返回-1。
一个简单的示例：
InputStream input = new FileInputStream("c:\\data\\input-file.txt");
int data = input.read(); 
while(data != -1){
     data = input.read();
}

OutputStream
java.io.OutputStream是Java IO中所有输出流的基类。
如果你正在开发一个能够将数据写入流中的组件，请尝试使用OutputStream替代它的所有子类。
一个简单的示例：
OutputStream output = new FileOutputStream("c:\\data\\output-file.txt");
output.write("Hello World".getBytes());
output.close();

组合流
你可以将流整合起来以便实现更高级的输入和输出操作。
比如，一次读取一个字节是很慢的，所以可以从磁盘中一次读取一大块数据，然后从读到的数据块中获取字节。
为了实现缓冲，可以把InputStream包装到BufferedInputStream中。
代码示例：
InputStream input = new BufferedInputStream(new FileInputStream("c:\\data\\input-file.txt"));
缓冲同样可以应用到OutputStream中。你可以实现将大块数据批量地写入到磁盘(或者相应的流)中，这个功能由BufferedOutputStream实现。
缓冲只是通过流整合实现的其中一个效果。你可以把InputStream包装到PushbackInputStream中，之后可以将读取过的数据推回到流中重新读取，在解析过程中有时候这样做很方便。
或者，你可以将两个InputStream整合成一个SequenceInputStream。
将不同的流整合到一个链中，可以实现更多种高级操作。
通过编写包装了标准流的类，可以实现你想要的效果和过滤器。


一个程序需要InputStream或者Reader从数据源读取数据，或者需要OutputStream或者Writer将数据写入到目标媒介中(InputStream和Reader与数据源相关联，OutputStream和writer与目标媒介相关联)
source---InputStream/Reader---program
program--OutputStream/Writer---destination


Java IO中包含了许多InputStream、OutputStream、Reader、Writer的子类。
这样设计的原因是让每一个类都负责不同的功能。

各类用途汇总如下：
文件访问
网络访问
内存缓存访问
线程内部通信(管道)
缓冲
过滤
解析
读写文本 (Readers / Writers)
读写基本类型数据 (long, int etc.)
读写对象

各个类的具体描述：

InputStream
InputStream用于读取基于字节的数据，一次读取一个字节
InputStream inputstream = new FileInputStream("c:\\data\\input-text.txt");
FileInputStream是InputStream的子类，所以可以把FileInputStream实例赋值给InputStream变量。

read()方法
read()方法返回从InputStream流内读取到的一个字节内容(译者注：0~255)，例子如下：
int data = inputstream.read();
可以把返回的int类型转化成char类型：
char aChar = (char) data;

InputStream的子类可能会包含read()方法的替代方法。
比如，DataInputStream允许你利用readBoolean()，readDouble()等方法读取Java基本类型变量int，long，float，double和boolean。

流末尾
如果read()方法返回-1，意味着程序已经读到了流的末尾，此时流内已经没有多余的数据可供读取了。-1是一个int类型，不是byte或者char类型，这是不一样的。
当达到流末尾时，你就可以关闭流了。

read(byte[])
InputStream包含了2个从InputStream中读取数据并将数据存储到缓冲数组中的read()方法，他们分别是：
int read(byte[])
int read(byte, int offset, int length)
一次性读取一个字节数组的方式，比一次性读取一个字节的方式快的多，所以，尽可能使用这两个方法代替read()方法。

read(byte[])方法会尝试读取与给定字节数组容量一样大的字节数，返回值说明了已经读取过的字节数。
如果InputStream内可读的数据不足以填满字节数组，那么数组剩余的部分将包含本次读取之前的数据。
记得检查有多少数据实际被写入到了字节数组中。

read(byte, int offset, int length)方法同样将数据读取到字节数组中，不同的是，该方法从数组的offset位置开始，并且最多将length个字节写入到数组中。
同样地，read(byte, int offset, int length)方法返回一个int变量，告诉你已经有多少字节已经被写入到字节数组中，
所以请记得在读取数据前检查上一次调用read(byte, int offset, int length)的返回值。

这两个方法都会在读取到达到流末尾时返回-1。

OutputStream：
OutputStream类是Java IO API中所有输出流的基类。子类包括BufferedOutputStream，FileOutputStream等等
当写入到输出流的数据逐渐输出完毕时，目标媒介是所有数据的归属地。
write(byte)方法
write(byte)方法用于把单个字节写入到输出流中。
OutputStream的write(byte)方法将一个包含了待写入数据的int变量作为参数进行写入。
只有int类型的第一个字节会被写入，其余位会被忽略。(译者注：写入低8位，忽略高24位)。

OutputStream的子类可能会包含write()方法的替代方法。
比如，DataOutputStream允许你利用writeBoolean()，writeDouble()等方法将基本类型int，long，float，double，boolean等变量写入。

一个OutputStream的write()方法例子：

OutputStream output = new FileOutputStream("c:\\data\\output-text.txt");
while(hasMoreData()) {
    int data = getMoreData();
    output.write(data);
}
output.close();
hasMoreData()的作用是：当有剩余可写数据时，返回true，否则返回false。
write(byte[])
OutputStream同样包含了将字节数据中全部或者部分数据写入到输出流中的方法，分别是write(byte[])和write(byte[], int offset, int length)。
write(byte[])把字节数组中所有数据写入到输出流中。
write(byte[], int offset, int length)把字节数据中从offset位置开始，length个字节的数据写入到输出流。

flush()
OutputStream的flush()方法将所有写入到OutputStream的数据冲刷到相应的目标媒介中。
比如，如果输出流是FileOutputStream，那么写入到其中的数据可能并没有真正写入到磁盘中。
即使所有数据都写入到了FileOutputStream，这些数据还是有可能保留在内存的缓冲区中。
通过调用flush()方法，可以把缓冲区内的数据刷新到磁盘(或者网络，以及其他任何形式的目标媒介)中。

close()
当你结束数据写入时，需要关闭OutputStream。通过调用close()可以达到这一点。
因为OutputStream的各种write()方法可能会抛出IO异常，所以你需要把调用close()的关闭操作方在finally块中执行。


FileInputStream：
FileInputStream可以以字节流的形式读取文件内容。
FileInputStream是InputStream的子类，这意味着你可以把FileInputStream当做InputStream使用(FileInputStream与InputStream的行为类似)。

一个FileInputStream的例子：
InputStream input = new FileInputStream("c:\\data\\input-text.txt");
int data = input.read();while(data != -1) {
    //do something with data...
    doSomethingWithData(data);
    data = input.read();
}
input.close();

FileInputStream也有其他的构造函数，允许你通过不同的方式读取文件。(请移步阅读源码)
根据官方文档，FileInputStream有三个构造器
Creates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system.
Creates a FileInputStream by using the file descriptor fdObj, which represents an existing connection to an actual file in the file system.
Creates a FileInputStream by opening a connection to an actual file, the file named by the path name name in the file system.

至于你该采用参数是String对象还是File对象的构造函数，取决于你当前是否已经拥有一个File对象，
也取决于你是否要在打开FileOutputStream之前通过File对象执行某些检查(比如检查文件是否存在)。

FileOutputStream
FileOutputStream可以往文件里写入字节流，它是OutputStream的子类，所以你可以像使用OutputStream那样使用FileOutputStream。

文件内容的覆盖Override、追加Appending
当你创建了一个指向已存在文件的FileOutputStream，你可以选择覆盖整个文件，或者在文件末尾追加内容。通过使用不同的构造函数可以实现不同的目的。
OutputStream output = new FileOutputStream("c:\\data\\output-text.txt");//overwrites file
OutputStream output = new FileOutputStream("c:\\data\\output-text.txt", true); //appends to file
OutputStream output = new FileOutputStream("c:\\data\\output-text.txt", false); //overwrites file

ByteArrayInputStream
ByteArrayOutputStream
ByteArrayInputStream允许你从字节数组中读取字节流数据
eg:
byte[] bytes = ... //get byte array from somewhere.
InputStream input = new ByteArrayInputStream(bytes);
int data = input.read();
while(data != -1) {
    //do something with data
    data = input.read();
}
input.close();

ByteArrayOutputStream允许你以数组的形式获取写入到该输出流中的数据
ByteArrayOutputStream output = new ByteArrayOutputStream();
//write data to output stream
byte[] bytes = output.toByteArray();


BufferedInputStream
BufferedOutputStream
BufferedInputStream能为输入流提供缓冲区，能提高很多IO的速度。
你可以一次读取一大块的数据，而不需要每次从网络或者磁盘中一次读取一个字节。特别是在访问大量磁盘数据时，缓冲通常会让IO快上许多。
为了给你的输入流加上缓冲，你需要把输入流包装到BufferedInputStream中.
InputStream input = new BufferedInputStream(new FileInputStream("c:\\data\\input-file.txt"));
很简单.你可以给BufferedInputStream的构造函数传递一个值，设置内部使用的缓冲区设置大小(译者注：默认缓冲区大小8 * 1024B)，就像这样：
InputStream input = new BufferedInputStream(new FileInputStream("c:\\data\\input-file.txt"), 8 * 1024);
这个例子设置了8KB的缓冲区。最好把缓冲区大小设置成1024字节的整数倍，这样能更高效地利用内置缓冲区的磁盘。
除了能够为输入流提供缓冲区以外，其余方面BufferedInputStream基本与InputStream类似

与BufferedInputStream类似，BufferedOutputStream可以为输出流提供缓冲区。可以构造一个使用默认大小缓冲区的BufferedOutputStream(译者注：默认缓冲区大小8 * 1024B)


DataInputStream
DataOutputStream
DataInputStream可以使你从输入流中读取Java基本类型数据，而不必每次读取字节数据。
你可以把InputStream包装到DataInputStream中，然后就可以从此输入流中读取基本类型数据了
DataInputStream input = new DataInputStream(new FileInputStream("binary.data"));
int aByte = input.read();
int anInt = input.readInt();
float aFloat = input.readFloat();
double aDouble = input.readDouble();//etc.
input.close();

DataOutputStream可以往输出流中写入Java基本类型数据，例子如下：
DataOutputStream output = new DataOutputStream(new FileOutputStream("binary.data"));
output.write(45);
//byte data output.writeInt(4545);
//int data output.writeDouble(109.123);
//double data  output.close();

ObjectInputStream
ObjectOutputStream
ObjectInputStream能够让你从输入流中读取Java对象，而不需要每次读取一个字节。
你可以把InputStream包装到ObjectInputStream中，然后就可以从中读取对象了
bjectInputStream input = new ObjectInputStream(new FileInputStream("object.data"));
MyClass object = (MyClass) input.readObject(); //etc.
input.close();
在这个例子中，你读取的对象必须是MyClass的一个实例，并且必须事先通过ObjectOutputStream序列化到“object.data”文件中

ObjectOutputStream能够让你把对象写入到输出流中，而不需要每次写入一个字节。
你可以把OutputStream包装到ObjectOutputStream中，然后就可以把对象写入到该输出流中了。
ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream("object.data"));
MyClass object = new MyClass();  output.writeObject(object); //etc.
output.close();
例子中序列化的对象object现在可以从ObjectInputStream中读取了。


Reader 
Writer
Reader是Java IO中所有Reader的基类。
Reader与InputStream类似，不同点在于，Reader基于字符而非基于字节。
换句话说，Reader用于读取文本，而InputStream用于读取原始字节。
Reader通常与文件、字符数组、网络等数据源相关联.
Java内部使用UTF8编码表示字符串。
输入流中一个字节可能并不等同于一个UTF8字符。如果你从输入流中以字节为单位读取UTF8编码的文本，并且尝试将读取到的字节转换成字符，你可能会得不到预期的结果。

read()方法返回一个包含了读取到的字符内容的int类型变量(译者注：0~65535)。如果方法返回-1，表明Reader中已经没有剩余可读取字符，此时可以关闭Reader。
-1是一个int类型，不是byte或者char类型，这是不一样的。
你通常会使用Reader的子类，而不会直接使用Reader。Reader的子类包括InputStreamReader，CharArrayReader，FileReader等等。

Writer是Java IO中所有Writer的基类。
与Reader和InputStream的关系类似，Writer基于字符而非基于字节，Writer用于写入文本，OutputStream用于写入字节。
同样，你最好使用Writer的子类，不需要直接使用Writer，因为子类的实现更加明确，更能表现你的意图。
常用子类包括OutputStreamWriter，CharArrayWriter，FileWriter等。
Writer的write(int c)方法，会将传入参数的低16位写入到Writer中，忽略高16位的数据。







