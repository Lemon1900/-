1. 单一责任原则；
2. 里氏替换原则；
3. 依赖倒置原则；
4. 接口隔离原则；
5. 迪米特法原则；
6. 开闭原则

以下，详细阐释
一、单一责任原则 SRP, Single Responsibility Principle
当一个类承担了过多的职责，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者一直这个类完成其他职责的能力。问题就出在耦合性上！
软件设计要做的工作是：发现职责并把那些职责互相分离。单一职责可使类的复杂性降低，其实现的工作有明确且清晰的定义。
降低两个功能块之间的耦合，可以让之后某一功能的修改拓展不会影响到另一功能。
一个接口的修改只对相应的实现类有影响，对其他接口无影响；有利于系统的可扩展性、可维护性。
 问题：
 “职责”的粒度不好确定！
过分细分的职责也会人为地增加系统复杂性。
 建议：
对于单一职责原则，建议 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。
只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则

二、里氏替换原则 LSP，Liskov Substitution Principle
所有引用基类的地方，都能透明地替换成其子类对象。只要父类能出现的地方，子类就可以出现。
引入里氏替换原则能充分发挥继承的优点、减少继承的弊端
继承的优点：
    代码共享，减少创建类的工作量；每个子类都有父类的方法和属性；
    提高代码重用性；
    子类可以形似父类，但又异于父类；
    提高代码可扩展性；
    提高产品开放性。

继承的缺点：
    继承是侵入性的——只要继承，就必须拥有父类的属性和方法；
    降低代码的灵活性——子类必须拥有父类的属性和方法，让子类自由的世界多了些约束；
    增强了耦合性——当父类的属性和方法被修改时，必须要考虑子类的修改。
    
建议：
在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，
程序运行出错的几率非常大。
父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，
但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。
里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。

如果真的遇见了不得不重写父类方法的场景，那么请你考虑，是否真的要把这个类作为子类出现在这里，或者说这样做所换来的是否能弥补你失去的东西，
比如子类无法代替父类工作，那么就意味着如果你的父类可以在某一个场景里工作的很正常，那么你的子类当然也应该可以
里氏替换原则是一个需要我们深刻理解的原则，因为往往有时候违反它我们可以得到很多，失去一小部分，但是有时候却会相反，所以要想做到活学活用，
就要深刻理解这个原则的意义所在。

三、依赖倒置原则 DIP，Dependence Inversion Principle
即“面向接口编程”
高层模块不应该依赖低层模块，两者都应该依赖其抽象；——模块间的依赖通过抽象发生。实现类之间不发生直接的依赖关系（eg. 类B被用作类A的方法中的参数），其依赖关系是通过接口或抽象类产生的；
抽象不应该依赖细节；——接口或抽象类不依赖于实现类；
细节应该依赖抽象；——实现类依赖接口或抽象类。

依赖正置：类间的依赖是实实在在的实现类间的依赖，即面向实现编程，这是正常人的思维方式；
而依赖倒置是对现实世界进行抽象，产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖。
依赖倒置可以减少类间的耦合性、降低并行开发引起的风险。

如果通过依赖注入的方式来实现程序的良性扩展，那么这个原则讲的就是这个依赖的对象，尽量通过抽象产生，即实现类之间不直接发生依赖关系，而是通过抽象类或接口来实现，
这样只要是继承或者承接自这个接口或抽象类的子类就可以成为依赖，大大提高了程序的可扩展性。

依赖有三种写法：
1）构造函数传递依赖对象（构造函数注入）
2）setter方法传递依赖对象（setter依赖注入）
3）接口声明依赖对象（接口注入）
 
 建议：
DIP的核心是面向接口编程；DIP的本质是通过抽象（接口、抽象类）使各个类或模块的实现彼此独立，不互相影响。

在项目中遵循以下原则：
每个类尽量都有接口或抽象类
变量的表面类型尽量使接口或抽象类
任何类都不应该从具体类派生*——否则就会依赖具体类。
尽量不要重写父类中已实现的方法——否则父类就不是一个真正适合被继承的抽象。
结合里氏替代原则使用

四、接口隔离原则 ISP, Interface Segregation Principle
接口尽量细化，接口中的方法尽量少
做不到这一点你经常会发现这样的状况，一个类实现了一个接口，里面很多方法都是空着的，只有个别几个方法实现了
最小接口原则一般我们是要尽量满足的，如果实在有多余的方法，我们也有补救的办法，而且有的时候也确实不可避免的有一些实现类无法全部实现接口中的方法，
这时候就轮到缺省适配器上场了

建议：
一个接口只服务于一个子模块或业务逻辑；
通过业务逻辑压缩接口中的public方法；
已被污染了的接口，尽量去修改；若变更的风险较大，则采用适配器模式转化处理；
拒绝盲从

与单一职责原则的区别：

二者审视角度不同；
单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分；
接口隔离原则要求接口的方法尽量少

五、迪米特法则 LoD，Law of Demeter （LKP, Least Knowledge Principle）
又称最少知识原则（Least Knowledge Principle），一个对象应该对其他对象有最少的了解
一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。
如果一个类知道或者说是依赖于另外一个类太多细节，这样会导致耦合度过高，应该将细节全部高内聚于类的内部，其他的类只需要知道这个类主要提供的功能即可。
所谓高内聚就是尽可能将一个类的细节全部写在这个类的内部，不要漏出来给其他类知道，否则其他类就很容易会依赖于这些细节，这样类之间的耦合度就会急速上升，这样做的后果往往是一个类随便改点东西，依赖于它的类全部都要改。
迪米特原则虽说是指的一个类应当尽量不要知道其他类太多细节，但其实更重要的是一个类应当不要让外部的类知道自己太多。两者是相辅相成的，只要你将类的封装性做的很好，那么外部的类就无法依赖当中的细节。

问题由来：
类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。

解决方案：

迪米特法则包含4层含义：
1）只和朋友交流
Only talk to your immediate friends.两个对象之间的耦合就成为朋友关系。即，出现在成员变量、方法输入输出参数中的类就是朋友；局部变量不属于朋友。
不与无关的对象发生耦合！
方针：不要调用从另一个方法中返回的对象中的方法！只应该调用以下方法：
    该对象本身的方法
    该对象中的任何组件的方法
    方法参数中传入的对象的方法
    方法内部实例化的对象的方法
    
2）朋友间也应该有距离
即使是朋友类之间也不能无话不说，无所不知。
 一个类公开的public属性或方法应该尽可能少！

3）是自己的就是自己的
如果一个方法放在本类中也可以、放在其他类中也可以，怎么办？
如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。

4）谨慎使用Serializable
否则，若后来修改了属性，序列化时会抛异常NotSerializableException。

建议：
迪米特法则的核心观念是：类间解耦。

其结果是产生了大量中转或跳转类。

六、开闭原则 OCP, Open Closed Principle
对扩展开放，对修改关闭。一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。
一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。但是并不意味着不做任何修改；底层模块的扩展，必然要有高层模块进行耦合。
这个原则更像是前五个原则的总纲，前五个原则就是围着它转的，只要我们尽量的遵守前五个原则，那么设计出来的系统应该就比较符合开闭原则了，相反，如果你违背了太多，那么你的系统或许也不太遵循开闭原则。

“变化”可分为三种类型：
逻辑变化——不涉及其他模块，可修改原有类中的方法；
子模块变化——会对其他模块产生影响，通过扩展来完成变化；
可见视图变化——界面变化，有时需要通过扩展来完成变化。

问题由来：
在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，
并且需要原有代码经过重新测试。

解决方案：
当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。要求：
1）抽象约束（要实现对扩展开放，首要前提就是抽象约束）
通过接口或抽象类可以约束一组可能变化的行为，并能实现对扩展开放。包含三层含义：
通过接口或抽象类可以约束扩展，对扩展进行边界限定，不允许出现在接口抽象类中不存在的public方法；
参数类型、引用对象尽量使用接口或抽象类，而不是实现类；
抽象应尽量保持稳定，一旦确定即不允许修改。
）元数据（metadata）控制模块行为
元数据，即用来描述环境和数据的数据，即配置数据。例如SpingContext。
3）制定项目章程
4）封装变化
封装可能发生的变化。将相同的变化封装到一个接口或抽象类中；将不同的变化封装到不同的接口或抽象类中。

好处：
易于单元测试
如果直接修改已有代码，则需要同时修改单元测试类；而通过扩展，则只需生成一个测试类。
可提高复用性
可提高可维护性
面向对象开发的要求

建议：
开闭原则是最基础的原则，前5个原则都是开闭原则的具体形态。
 
 
用抽象构建框架，用细节实现扩展
