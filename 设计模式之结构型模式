设计模式的结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
其中对象的适配器模式是各种模式的起源。

一、适配器模式
适配器模式是将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。
主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。

1.类的适配器模式,核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里。
Adapter类继承Source类，实现Targetable接口，这样Targetable接口的实现类（Adapter）就具有了Source类的功能。

2.对象的适配器模式
Adapter类实现Targetable接口,持有Source类的实例，以达到解决兼容性的问题.

3.接口的适配器模式
当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可.
有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，
因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，
该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，
所以我们写一个类，继承该抽象类，重写我们需要的方法就行.

二、代理模式
代理模式在很多情况下都非常有用,特别是在强行控制一个对象的时候,比如:延迟加载,监视状态变更的方法等
对外部提供统一的接口方法，而代理类在接口中实现对真实类的附加操作行为，从而可以在不影响外部调用情况下，进行系统扩展

抽象角色(接口)：声明真实对象和代理对象的共同接口。
代理角色(代理类)：代理对象角色(实现接口)内部含有对真实对象的引用(持有真实角色)，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。
               同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。
真实角色(真实类)：代理角色所代表的真实对象(实现接口)，是我们最终要引用的对象。

1、静态代理
三步即可实现。首先，我们需要定义业务接口，业务接口实现类，然后定义代理类，且实现业务接口；最后写一个Client来调用。
静态代理 静态代理需要在运行之前就写好代理类，这样就造成了代码的大量重复，每一个代理类只能为一个接口服务 缺点

2.动态代理
动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，
而且提高了软件系统的可扩展性，Java 反射机制可以生成任意类型的动态代理类。



